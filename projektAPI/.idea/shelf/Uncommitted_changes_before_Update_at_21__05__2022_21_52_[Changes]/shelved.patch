Index: app.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>var createError = require('http-errors');\r\nvar express = require('express');\r\nvar path = require('path');\r\nvar cookieParser = require('cookie-parser');\r\nvar logger = require('morgan');\r\n\r\nvar indexRouter = require('./routes/index');\r\nvar usersRouter = require('./routes/users');\r\nvar neobdelani_podatkiRouter = require('./routes/neobdelani_podatkiRoutes');\r\nvar obdelani_podatkiRouter = require('./routes/obdelani_podatkiRoutes');\r\nvar rezultatRouter = require('./routes/rezultatRoutes');\r\nvar scrapperRouter = require('./routes/scrapper_podatkiRoutes');\r\n\r\nvar app = express();\r\n\r\nvar cors = require('cors');\r\nvar allowedOrigins = ['http://localhost:3000', 'http://localhost:3001'];\r\napp.use(cors({\r\n  credentials: true,\r\n  origin: function(origin, callback){\r\n    // Allow requests with no origin (mobile apps, curl)\r\n    if(!origin) return callback(null, true);\r\n    if(allowedOrigins.indexOf(origin)===-1){\r\n      var msg = \"The CORS policy does not allow access from the specified Origin.\";\r\n      return callback(new Error(msg), false);\r\n    }\r\n    return callback(null, true);\r\n  }\r\n}));\r\n\r\nvar mongoose = require('mongoose');\r\nvar mongoDB = 'mongodb+srv://test:test@cluster0.to3tv.mongodb.net/?retryWrites=true&w=majority'\r\n//var mongoDB = 'mongodb://127.0.0.1/Scrapper';\r\nmongoose.connect(mongoDB);\r\nmongoose.Promise = global.Promise;\r\nvar db = mongoose.connection;\r\ndb.on('error', console.error.bind(console, 'MongoDB connection failed'));\r\n\r\n// view engine setup\r\napp.set('views', path.join(__dirname, 'views'));\r\napp.set('view engine', 'hbs');\r\n\r\napp.use(logger('dev'));\r\napp.use(express.json());\r\napp.use(express.urlencoded({ extended: false }));\r\napp.use(cookieParser());\r\napp.use(express.static(path.join(__dirname, 'public')));\r\n\r\napp.use('/', indexRouter);\r\napp.use('/users', usersRouter);\r\napp.use('/neobdelaniPodatki', neobdelani_podatkiRouter);\r\napp.use('/obdelaniPodatki', obdelani_podatkiRouter);\r\napp.use('/rezultat', rezultatRouter);\r\napp.use('/scrapper', scrapperRouter);\r\n\r\n// catch 404 and forward to error handler\r\napp.use(function(req, res, next) {\r\n  next(createError(404));\r\n});\r\n\r\n// error handler\r\napp.use(function(err, req, res, next) {\r\n  // set locals, only providing error in development\r\n  res.locals.message = err.message;\r\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\r\n\r\n  // render the error page\r\n  res.status(err.status || 500);\r\n  res.render('error');\r\n});\r\n\r\nmodule.exports = app;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.js b/app.js
--- a/app.js	
+++ b/app.js	
@@ -29,8 +29,8 @@
 }));
 
 var mongoose = require('mongoose');
-var mongoDB = 'mongodb+srv://test:test@cluster0.to3tv.mongodb.net/?retryWrites=true&w=majority'
-//var mongoDB = 'mongodb://127.0.0.1/Scrapper';
+//var mongoDB = 'mongodb+srv://test:test@cluster0.to3tv.mongodb.net/?retryWrites=true&w=majority'
+var mongoDB = 'mongodb://127.0.0.1/Projekt';
 mongoose.connect(mongoDB);
 mongoose.Promise = global.Promise;
 var db = mongoose.connection;
Index: ../mobileApp/app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"com.example.npo_agregat\">\r\n\r\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\r\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\r\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\r\n    <uses-permission android:name=\"android.permission.HIGH_SAMPLING_RATE_SENSORS\" />\r\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\r\n    <uses-permission android:name=\"android.permission.ACTIVITY_RECOGNITION\"/>\r\n    <application\r\n        android:usesCleartextTraffic=\"true\"\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.NPOAgregat\"\r\n        android:name=\".MyApplication\">\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n    </application>\r\n\r\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../mobileApp/app/src/main/AndroidManifest.xml b/../mobileApp/app/src/main/AndroidManifest.xml
--- a/../mobileApp/app/src/main/AndroidManifest.xml	
+++ b/../mobileApp/app/src/main/AndroidManifest.xml	
@@ -3,11 +3,12 @@
     package="com.example.npo_agregat">
 
     <uses-permission android:name="android.permission.INTERNET"/>
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
-    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
     <uses-permission android:name="android.permission.HIGH_SAMPLING_RATE_SENSORS" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
     <uses-permission android:name="android.permission.ACTIVITY_RECOGNITION"/>
+    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
     <application
         android:usesCleartextTraffic="true"
         android:allowBackup="true"
Index: ../mobileApp/app/src/main/java/com/example/npo_agregat/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.npo_agregat\r\n\r\nimport android.Manifest\r\nimport android.content.Context\r\nimport android.content.pm.PackageManager\r\nimport android.hardware.Sensor\r\nimport android.hardware.SensorEvent\r\nimport android.hardware.SensorEventListener\r\nimport android.hardware.SensorManager\r\nimport android.location.Location\r\nimport android.location.LocationManager\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.os.Bundle\r\nimport android.os.Looper\r\nimport android.util.Half.EPSILON\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport com.example.npo_agregat.databinding.ActivityMainBinding\r\nimport com.google.android.gms.location.*\r\nimport java.io.BufferedReader\r\nimport java.io.InputStreamReader\r\nimport java.io.OutputStreamWriter\r\nimport kotlin.math.cos\r\nimport kotlin.math.sin\r\nimport kotlin.math.sqrt\r\nimport java.net.HttpURLConnection\r\nimport java.net.URL\r\nimport java.net.URLEncoder\r\nimport android.os.StrictMode\r\nimport android.os.StrictMode.ThreadPolicy\r\nimport okhttp3.*\r\n\r\nimport java.io.IOException\r\nimport java.net.Proxy\r\n\r\n\r\nclass MainActivity : AppCompatActivity(){\r\n    private lateinit var binding: ActivityMainBinding\r\n    lateinit var app:MyApplication\r\n    private lateinit var fusedLocationClient: FusedLocationProviderClient\r\n    private lateinit var locationRequest: LocationRequest\r\n    private lateinit var locationCallback: LocationCallback\r\n    private lateinit var sensorManager: SensorManager\r\n    private val NS2S = 1.0f / 1000000000.0f\r\n    private val deltaRotationVector = FloatArray(4) { 0f }\r\n    private var timestamp: Float = 0f\r\n    private val client = OkHttpClient()\r\n    //private var mAccelerometer : Sensor ?= null\r\n    //private var mGyroscope : Sensor ?= null\r\n    private var tmp1: Float=0.0f\r\n    private var tmp2: Float=0.0f\r\n    private var tmp3: Float=0.0f\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n        app = application as MyApplication\r\n\r\n        val policy = ThreadPolicy.Builder().permitAll().build()\r\n        StrictMode.setThreadPolicy(policy)\r\n\r\n        // Dovoljenja\r\n        if ((ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) && (ContextCompat.checkSelfPermission(this, Manifest.permission.HIGH_SAMPLING_RATE_SENSORS) != PackageManager.PERMISSION_GRANTED)) {\r\n            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.HIGH_SAMPLING_RATE_SENSORS), 2)\r\n        }\r\n        // Google location provider\r\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\r\n        createLocationRequest()\r\n\r\n\r\n        // OnClick\r\n        binding.btnStart.setOnClickListener {\r\n            if(binding.tvStatus.text == getString(R.string.textview_status_idle)){\r\n                binding.tvStatus.text = getString(R.string.textview_status_capturing)\r\n                // Zacni zajemanje podatkov\r\n                app.isCapturing = true\r\n                startLocationUpdates()\r\n                setUpSensorStuff()\r\n                Log.e(\"x_pospesek\",app.accelerationX.toString())\r\n\r\n            }\r\n        }\r\n        binding.btnStop.setOnClickListener {\r\n            if(binding.tvStatus.text == getString(R.string.textview_status_capturing)){\r\n                binding.tvStatus.text = getString(R.string.textview_status_idle)\r\n                // Prenehaj zajemanje podatkov\r\n                Log.e(\"x_pospesek\",app.accelerationX.toString())\r\n                app.isCapturing = false\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun sendPost(location: Location) {\r\n        val locationString = location.latitude.toString() + \", \" + location.longitude.toString()\r\n        // Spremeni na pravilen IP od API (za testiranje more bit local IP, na localhost/127.0.0.1 se ne poveze)\r\n        //val actualUrl = \"192.168.178.55:3000\"\r\n        //val actualUrl = \"192.168.1.27:3000\"\r\n        //val actualUrl = \"localhost:3000\"\r\n        val actualUrl = \"192.168.178.55:3001\"\r\n\r\n        val requestBody = FormBody.Builder()\r\n            .add(\"x_rotacija\", app.gyroscopeX.toString())\r\n            .add(\"y_rotacija\", app.gyroscopeY.toString())\r\n            .add(\"z_rotacija\", app.gyroscopeZ.toString())\r\n            .add(\"x_pospesek\", app.accelerationX.toString())\r\n            .add(\"y_pospesek\", app.accelerationY.toString())\r\n            .add(\"z_pospesek\", app.accelerationZ.toString())\r\n            .add(\"koordinate\", locationString)\r\n            .build()\r\n\r\n        val request = Request.Builder()\r\n            .url(\"http://$actualUrl/neobdelaniPodatki\")\r\n            .post(requestBody)\r\n            .build()\r\n\r\n        client.newCall(request).execute().use { response ->\r\n            if (!response.isSuccessful) Log.e(\"Unexpected code\", response.toString())\r\n            else {\r\n                val responseHeaders: Headers = response.headers\r\n                for (i in 0 until responseHeaders.size) {\r\n                    // Log.e(\"x_pospesek\",app.accelerationX.toString())\r\n                    println(responseHeaders.name(i).toString() + \": \" + responseHeaders.value(i))\r\n                }\r\n                System.out.println(response.body!!.string())\r\n            }\r\n        }\r\n\r\n        /*\r\n        var reqParam = URLEncoder.encode(\"?stanje_ceste=10&koordinate=32123,32123\", \"UTF-8\")\r\n        val mURL = URL(\"http://192.168.178.55:3000/rezultat\")\r\n\r\n        with(mURL.openConnection() as HttpURLConnection) {\r\n            setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\")\r\n            requestMethod = \"POST\"\r\n            doOutput = true\r\n\r\n            val wr = OutputStreamWriter(outputStream)\r\n            wr.write(reqParam)\r\n            wr.flush()\r\n\r\n            println(\"URL : $url\")\r\n            println(\"Response Code : $responseCode\")\r\n            println(\"Response message : $responseMessage\")*/\r\n            /*\r\n            BufferedReader(InputStreamReader(inputStream)).use {\r\n                val response = StringBuffer()\r\n\r\n                var inputLine = it.readLine()\r\n                while (inputLine != null) {\r\n                    response.append(inputLine)\r\n                    inputLine = it.readLine()\r\n                }\r\n                println(\"Response : $response\")\r\n            }\r\n            disconnect()*/\r\n\r\n    }\r\n\r\n    private fun setUpSensorStuff() {\r\n        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager\r\n\r\n        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)?.also { accelerometer ->\r\n            sensorManager.registerListener(\r\n                mAcceleratorSensorListener,\r\n                accelerometer,\r\n                SensorManager.SENSOR_DELAY_UI,\r\n                SensorManager.SENSOR_DELAY_UI\r\n            )\r\n        }\r\n\r\n        sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE)?.also { gyroscope ->\r\n            sensorManager.registerListener(\r\n                mGyroscopeSensorListener,\r\n                gyroscope,\r\n                SensorManager.SENSOR_DELAY_UI,\r\n                SensorManager.SENSOR_DELAY_UI\r\n            )\r\n        }\r\n    }\r\n\r\n    // Pospeškometer\r\n    private val mAcceleratorSensorListener: SensorEventListener = object : SensorEventListener {\r\n        override fun onSensorChanged(event: SensorEvent) {\r\n            // In this example, alpha is calculated as t / (t + dT),\r\n            // where t is the low-pass filter's time-constant and\r\n            // dT is the event delivery rate.\r\n\r\n            val alpha: Float = 0.8f\r\n            // Isolate the force of gravity with the low-pass filter.\r\n            val gravity = arrayOf(0.0, 0.0, 0.0)\r\n            val linear_acceleration = arrayOf(0.0, 0.0, 0.0)\r\n            gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0]\r\n            gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1]\r\n            gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2]\r\n\r\n            // Remove the gravity contribution with the high-pass filter.\r\n\r\n            linear_acceleration[0] = event.values[0] - gravity[0]\r\n            linear_acceleration[1] = event.values[1] - gravity[1]\r\n            linear_acceleration[2] = event.values[2] - gravity[2]\r\n            //Log.e(\"X Speed: \", linear_acceleration[0].toString())\r\n            //Log.e(\"Acceleration 1: \", linear_acceleration[1].toString())\r\n            //Log.e(\"Acceleration 2: \", linear_acceleration[2].toString())\r\n            app.accelerationX=linear_acceleration[0]\r\n            app.accelerationY=linear_acceleration[1]\r\n            app.accelerationZ=linear_acceleration[2]\r\n\r\n        }\r\n\r\n        override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {\r\n\r\n        }\r\n    }\r\n\r\n\r\n    // Rotacija\r\n    private val mGyroscopeSensorListener: SensorEventListener = object : SensorEventListener {\r\n        override fun onSensorChanged(event: SensorEvent) {\r\n            // This timestep's delta rotation to be multiplied by the current rotation\r\n            // after computing it from the gyro sample data.\r\n            if (timestamp != 0f && event != null) {\r\n                val dT = (event.timestamp - timestamp) * NS2S\r\n                // Axis of the rotation sample, not normalized yet.\r\n                var axisX: Float = event.values[0]\r\n                var axisY: Float = event.values[1]\r\n                var axisZ: Float = event.values[2]\r\n\r\n                // Calculate the angular speed of the sample\r\n                val omegaMagnitude: Float = sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ)\r\n\r\n                // Normalize the rotation vector if it's big enough to get the axis\r\n                // (that is, EPSILON should represent your maximum allowable margin of error)\r\n                if (omegaMagnitude > EPSILON) {\r\n                    axisX /= omegaMagnitude\r\n                    axisY /= omegaMagnitude\r\n                    axisZ /= omegaMagnitude\r\n                }\r\n\r\n                // Integrate around this axis with the angular speed by the timestep\r\n                // in order to get a delta rotation from this sample over the timestep\r\n                // We will convert this axis-angle representation of the delta rotation\r\n                // into a quaternion before turning it into the rotation matrix.\r\n                val thetaOverTwo: Float = omegaMagnitude * dT / 2.0f\r\n                val sinThetaOverTwo: Float = sin(thetaOverTwo)\r\n                val cosThetaOverTwo: Float = cos(thetaOverTwo)\r\n                deltaRotationVector[0] = sinThetaOverTwo * axisX\r\n                deltaRotationVector[1] = sinThetaOverTwo * axisY\r\n                deltaRotationVector[2] = sinThetaOverTwo * axisZ\r\n                deltaRotationVector[3] = cosThetaOverTwo\r\n            }\r\n            timestamp = event?.timestamp?.toFloat() ?: 0f\r\n            val deltaRotationMatrix = FloatArray(9) { 0f }\r\n            SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector)\r\n            // User code should concatenate the delta rotation we computed with the current rotation\r\n            // in order to get the updated rotation.\r\n            // rotationCurrent = rotationCurrent * deltaRotationMatrix;\r\n\r\n            /*Log.e(\"Rotation------x:\", deltaRotationVector[0].toString())//,deltaRotationVector[1].toString(),deltaRotationVector[2].toString())\r\n            Log.e(\"Rotationy:\", deltaRotationVector[1].toString())\r\n            Log.e(\"Rotationz:\", deltaRotationVector[2].toString())*/\r\n            app.gyroscopeX = deltaRotationVector[0]\r\n            app.gyroscopeY = deltaRotationVector[1]\r\n            app.gyroscopeZ = deltaRotationVector[2]\r\n\r\n        }\r\n        override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {\r\n\r\n        }\r\n    }\r\n\r\n    private fun createLocationRequest()\r\n    {\r\n\r\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\r\n        locationRequest = LocationRequest()\r\n        locationRequest.interval = 5000\r\n        locationRequest.fastestInterval = 500\r\n        locationRequest.smallestDisplacement = 5f // 170 m = 0.1 mile\r\n        locationRequest.priority = LocationRequest.PRIORITY_HIGH_ACCURACY //set according to your app function\r\n        locationCallback = object : LocationCallback() {\r\n            override fun onLocationResult(locationResult: LocationResult?) {\r\n                locationResult ?: return\r\n                if (locationResult.locations.isNotEmpty()) {\r\n                    val location = locationResult.lastLocation\r\n                    sendPost(location)\r\n                    Toast.makeText(applicationContext, \"Location updated \" + location.longitude.toString() + \" \" + location.latitude.toString(), Toast.LENGTH_LONG).show()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun startLocationUpdates() {\r\n        if (ActivityCompat.checkSelfPermission(\r\n                this,\r\n                Manifest.permission.ACCESS_FINE_LOCATION\r\n            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(\r\n                this,\r\n                Manifest.permission.ACCESS_COARSE_LOCATION\r\n            ) != PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            return\r\n        }\r\n\r\n        fusedLocationClient.requestLocationUpdates(\r\n            locationRequest,\r\n            locationCallback,\r\n            Looper.getMainLooper()\r\n        )\r\n    }\r\n\r\n    // stop location updates\r\n    private fun stopLocationUpdates() {\r\n        fusedLocationClient.removeLocationUpdates(locationCallback)\r\n    }\r\n\r\n    // stop receiving location update when activity not visible/foreground\r\n    override fun onPause() {\r\n        super.onPause()\r\n        if(app.isCapturing)\r\n            stopLocationUpdates()\r\n    }\r\n\r\n    // start receiving location update when activity  visible/foreground\r\n    override fun onResume() {\r\n        super.onResume()\r\n        if(app.isCapturing)\r\n            startLocationUpdates()\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../mobileApp/app/src/main/java/com/example/npo_agregat/MainActivity.kt b/../mobileApp/app/src/main/java/com/example/npo_agregat/MainActivity.kt
--- a/../mobileApp/app/src/main/java/com/example/npo_agregat/MainActivity.kt	
+++ b/../mobileApp/app/src/main/java/com/example/npo_agregat/MainActivity.kt	
@@ -93,12 +93,13 @@
     }
 
     private fun sendPost(location: Location) {
+        println("HOHOHOHHO");
         val locationString = location.latitude.toString() + ", " + location.longitude.toString()
         // Spremeni na pravilen IP od API (za testiranje more bit local IP, na localhost/127.0.0.1 se ne poveze)
         //val actualUrl = "192.168.178.55:3000"
-        //val actualUrl = "192.168.1.27:3000"
+        val actualUrl = "192.168.1.27:3001"
         //val actualUrl = "localhost:3000"
-        val actualUrl = "192.168.178.55:3001"
+        //val actualUrl = "192.168.178.55:3001"
 
         val requestBody = FormBody.Builder()
             .add("x_rotacija", app.gyroscopeX.toString())
@@ -279,14 +280,16 @@
         locationRequest.fastestInterval = 500
         locationRequest.smallestDisplacement = 5f // 170 m = 0.1 mile
         locationRequest.priority = LocationRequest.PRIORITY_HIGH_ACCURACY //set according to your app function
+        Log.e("Oj","haahha")
         locationCallback = object : LocationCallback() {
-            override fun onLocationResult(locationResult: LocationResult?) {
+            override fun onLocationResult(locationResult: LocationResult) {
                 locationResult ?: return
                 if (locationResult.locations.isNotEmpty()) {
                     val location = locationResult.lastLocation
                     sendPost(location)
                     Toast.makeText(applicationContext, "Location updated " + location.longitude.toString() + " " + location.latitude.toString(), Toast.LENGTH_LONG).show()
                 }
+
             }
         }
     }
diff --git a/../projektUI/.idea/.gitignore b/../projektUI/.idea/.gitignore
new file mode 100644
diff --git a/../projektUI/.idea/vcs.xml b/../projektUI/.idea/vcs.xml
new file mode 100644
diff --git a/../projektUI/projekt-ui/.idea/inspectionProfiles/Project_Default.xml b/../projektUI/projekt-ui/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
diff --git a/../projektUI/.idea/inspectionProfiles/Project_Default.xml b/../projektUI/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
diff --git a/../projektUI/.idea/modules.xml b/../projektUI/.idea/modules.xml
new file mode 100644
diff --git a/../projektUI/.idea/projektUI.iml b/../projektUI/.idea/projektUI.iml
new file mode 100644
